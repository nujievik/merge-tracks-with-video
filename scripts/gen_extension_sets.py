from pathlib import Path
import itertools

PROJECT_DIR = Path(__file__).resolve().parent.parent
GEN_BY = Path(__file__).relative_to(PROJECT_DIR)
MODULE = PROJECT_DIR / "src" / "types" / "extensions"

OUT_PATHS = {
    "audio": MODULE / "audio.rs",
    "fonts": MODULE / "fonts.rs",
    "matroska": MODULE / "matroska.rs",
    "rtm_subs": MODULE / "rtm_subs.rs",
    "subs": MODULE / "subs.rs",
    "track_in": MODULE / "track_in.rs",
    "video": MODULE / "video.rs",
}

EXTS = {
    # Common for video and audio
    'container': {
        '3gp',
        'av1',
        'avi',
        'f4v',
        'flv',
        'm2ts',
        'mkv',
        'mp4',
        'mpg',
        'mov',
        'mpeg',
        'ogg',
        'ogm',
        'ogv',
        'ts',
        'webm',
        'wmv'
    },

    'video': {
        '264',
        '265',
        'avc',
        'h264',
        'h265',
        'hevc',
        'ivf',
        'm2v',
        'mpv',
        'obu',
        'vc1',
        'x264',
        'x265',
        'm4v'
    },

    'audio': {
        'aac',
        'ac3',
        'caf',
        'dts',
        'dtshd',
        'eac3',
        'ec3',
        'flac',
        'm4a',
        'mka',
        'mlp',
        'mp2',
        'mp3',
        'mpa',
        'opus',
        'ra',
        'thd',
        'truehd',
        'tta',
        'wav',
        'weba',
        'webma',
        'wma'
    },

    'subs': [
        'ass',
        'mks',
        'srt',
        'ssa',
        'sub',
        'sup'
    ],

    'fonts': [
        'otf',
        'ttf'
    ],

    'matroska': [
        'mka',
        'mks',
        'mkv',
        # WebM global metadata is based on the Matroska tag specs.
        # Also mkvinfo is support .webm
        'webm'
    ],

    'rtm_subs': [
        'ass',
        'srt'
    ],
}

EXTS["video"] = sorted(EXTS["video"].union(EXTS["container"]))
EXTS["audio"] = sorted(EXTS["audio"].union(EXTS["container"]))
EXTS['track_in'] = sorted(set(EXTS['video']) | set(EXTS['audio']) | set(EXTS['subs']))


def case_permutations(ext: str) -> set[str]:
    """Generate all case permutations of a string."""
    return {''.join(p) for p in itertools.product(*[(c.lower(), c.upper()) for c in ext])}


def generate_phf_set(exts: list[str], set_name: str) -> str:
    all_exts = []
    for ext in exts:
        perms = sorted(case_permutations(ext))
        all_exts.extend(perms)
    lines = ';\n    '.join(f'set.insert(OsStr::new("{e}"))' for e in all_exts)
    lines += ";"
    return f"""// Auto-generated by {GEN_BY}

use once_cell::sync::Lazy;
use std::collections::HashSet;
use std::ffi::OsStr;

pub static {set_name.upper()}: Lazy<HashSet<&'static OsStr>> = Lazy::new(|| {{
    let mut set = HashSet::new();
    {lines}
    set
}});
"""


def main():
    for name, path in OUT_PATHS.items():
        content = generate_phf_set(EXTS[name], name)
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding='utf-8')
        print(f"âœ… Generated -> {path}")


if __name__ == "__main__":
    main()
